#ifndef _Inprocessor_h_
#define _Inprocessor_h_

#include "Preprocessor.h"
#include "Primitive_Types/Lit_Equivalency.h"
#include "Component_Types/Component_Cache.h"


namespace KCBox {


class Inprocessor: public Preprocessor
{
protected:
	unsigned _unsimplifiable_num_vars;  /// the number of variables which is not simplified in Preprocess()
	vector<Literal> * _extra_binary_clauses;   /// NOTE: generated by the units of minisat
	Chain _var_order;  // used for minfill
	double * _var_scores;  // used for VSADS, DLCS
	double * _lit_scores;  // used for DLCP
	vector<Variable> _projected_vars;
	vector<bool> _var_projected;  // used for projected mc and compilation
	vector<Model *> * _models_stack;
	vector<Variable> * _binary_var_membership_lists;  /// variable membership
	vector<unsigned> * _ternary_var_membership_lists;  /// <clauseID, first var, second var, third var>
	vector<unsigned> * _quaternary_var_membership_lists;  /// <clauseID, first var, second var, third var, fourth var>
	vector<unsigned> * _long_var_membership_lists;  /// variable membership
	Component * _comp_stack;  // recording all components on the path
	unsigned _num_comp_stack;
	unsigned * _comp_offsets;  // recording decomposing status (+1 is decision), and the level i of components ranges from comp_point[i] to comp_point[i + 1]
	unsigned * _active_comps;  // recording the current component which is being compiled
	unsigned * _state_stack; // recording the state of the active component, for decision level, 0: prepare; 1: false; 2: true; 3: backtrack
	Lit_Equivalency _lit_equivalency;
public:
	Inprocessor();
	virtual ~Inprocessor() = 0;
	size_t Memory();
	void Set_Imp_Strategy( Implicate_Computing_Strategy strategy ) { running_options.imp_strategy = strategy; }
protected:
	void Allocate_and_Init_Auxiliary_Memory( Variable max_var );
	void Free_Auxiliary_Memory();
	void Reset();
	void Open_Oracle_Mode( Variable var_bound );
	void Close_Oracle_Mode();
	void Gather_Infor_For_Counting();
	void Generate_Membership_Lists();  /// _long_var_membership_lists records GE 3 cases
	void Generate_Membership_Lists_Subdivision();  /// _long_var_membership_lists records GT 4 cases
	void Generate_Membership_Lists_Subdivision_Binary();  /// _long_var_membership_lists records GE 3 cases
	void Generate_Membership_Lists_Subdivision_Long();  /// _long_var_membership_lists records GE 3 cases
	void Generate_Var_Membership_Lists();
	bool Var_Appeared( Variable var ) const;  // omit unary clauses and literal equivalences
	unsigned Num_Var_Appearances( Variable var ) const;  // omit unary clauses and literal equivalences
	unsigned Num_Omitted_Vars() const { return NumVars( _max_var ) - _unsimplifiable_num_vars - _fixed_num_vars; }
protected:  /// Var Heuristic
	void Compute_Var_Order_Min_Fill_Heuristic_Bound( unsigned bound );
	void Compute_Var_Order_Min_Fill_Heuristic_Opt();
	Greedy_Graph * Create_Primal_Graph();
	Greedy_Graph * Create_Primal_Graph_With_Sorting();
	Greedy_Graph * Create_Primal_Graph_Without_Sorting();
	void Var_Weight_For_Tree_Decomposition( double * var_weight );
	void Var_Weight_For_Tree_Decomposition_With_Sorting( double * var_weight );
	void Var_Weight_For_Tree_Decomposition_Without_Sorting( double * var_weight );
	void Compute_Var_Order_Flow_Cutter();
	void Generate_Var_Order_From_TreeD( Simple_TreeD & treed );
	void Generate_Var_Order_From_TreeD( Simple_TreeD & treed, double * var_weight );
	void Compute_Var_Order_Lexicographic();
	void Compute_Var_Order_Single_Cluster();
	void Propagate_Var_Order_Weight( Variable var, double * var_weight );
	void Compute_Dynamic_Min_Fill_Bound( unsigned bound );
	Variable Pick_Good_Var_Component( Component & comp );
	Variable Pick_Good_Var_Linearly_Component( Component & comp );
	Variable Pick_Good_Var_Dminfill_Component( Component & comp );
	void Lit_Scores_DLCP( Component & comp );
	Variable Pick_Good_Var_VSADS_Component( Component & comp );
	Variable Pick_Good_Var_VSADS_Improved_Component( Component & comp );
	double Var_Score_VSADS( unsigned var );
	double Var_Score_VSADS_With_Sorting( unsigned var );
	double Var_Score_VSADS_Without_Sorting( unsigned var );
	Variable Pick_Good_Var_DLCS_Component( Component & comp );
	Variable Pick_Good_Var_DLCP_Component( Component & comp );
	Variable Pick_Good_Projected_Var_Linearly_Component( Component & comp );
	void Rename_Clauses_Fixed_Ordering();
	unsigned Compute_Var_Order_Min_Fill_Bound_Component( Component & comp, unsigned bound );
	Greedy_Graph * Create_Weighted_Primal_Graph_Component( Component & comp, double * var_weight );
	void Generate_Var_Order_Min_Fill_Component( Component & comp, Simple_TreeD & treed, double * var_weight );
protected:  /// Lit Heuristic
	Literal Pick_Good_Lit_Component( Component & comp );
	Literal Pick_Good_Lit_Linearly_Component( Component & comp );
	void Lit_Appearances_Component( Component & comp, Variable var, unsigned appearances[] );
	Literal Pick_Good_Lit_DLCP_Component( Component & comp );
protected:  /// compute implied literals by IBCP
	Reason Get_Approx_Imp_Component( Component & comp, unsigned & backjump_level );
	Reason Get_Approx_Imp_Component_Full_IBCP( Component & comp );
	Reason BCP_Component( Component & comp, unsigned start );  // only propagate the variables in comp
	unsigned Analyze_Conflict_Decision( Reason confl );
	Reason Add_Learnt();
	unsigned Analyze_Conflict_Fixed_UIP( Reason confl, Literal fixed );
	Reason Get_Approx_Imp_Component_Partial_IBCP( Component & comp );
	Reason Get_Approx_Imp_Component_Partial_IBCP_Neg( Component & comp );
protected:  /// compute implied literals by calling SAT solver
	void Get_All_Imp_Component_SAT( Component & comp, vector<Model *> & models );
	void Get_All_Imp_Component( Component & comp, vector<Model *> & models );
	void Mark_Models_Component( Component & comp, vector<Model *> & models );
	void Init_Heur_Decaying_Sum_Component( Component & comp );
	void Init_Heur_Decaying_Sum_Sorted_Lists_Component( Component & comp );
	void Init_Heur_Decaying_Sum_Heap_Component( Component & comp );
	bool Learnts_Exploded();  /// this function used when counting is different from preprocessing
	void Filter_Long_Learnts();  /// this function used when counting is different from preprocessing
	Literal Pick_Imp_Component_Heuristic( Component & comp, vector<unsigned>::const_iterator & start );
	Reason Imply_Lit_Out_Reason_Component( Component & comp, Literal lit, vector<Model *> & models );
	unsigned Restart_Bound_Component( Component & comp );
	void Add_Marked_Model_Component( Component & comp, vector<Model *> & models );
	void Get_All_Imp_Component_External( Component & comp, vector<Model *> & models );
	void Get_All_Imp_Component_MiniSat( Component & comp, vector<Model *> & models );
	void Prepare_Renamed_Ext_Clauses_Component( Component & comp, vector<vector<int>> & eclauses );
	unsigned Analyze_Conflict_Naive( Literal uip );
	void Add_Extra_Binary_Clause_Naive( Literal lit1, Literal lit2 );
	void Add_Model_Component( vector<int8_t> & minisat_model, Component & comp, vector<Model *> & models );
	unsigned Num_Projected_Vars_Assigned( unsigned start );
	void Reset_Extra_Binary_Clauses();
	void Get_All_Imp_Component_CaDiCaL( Component & comp, vector<Model *> & models );
	unsigned Analyze_Conflict_CaDiCaL( Literal uip );
	void Verify_All_Imp_Component( Component & comp );
protected:  /// compute projected implied literals by calling SAT solver
	void Get_All_Projected_Imp_Component( Component & comp, vector<Model *> & models );
	Literal Pick_Projected_Imp_Component_Heuristic( Component & comp, vector<unsigned>::const_iterator & start );
	Reason Imply_Projected_Lit_Out_Reason_Component( Component & comp, Literal lit, vector<Model *> & models );
	Reason Search_Solution_Projected_Component( Component & comp, unsigned conf_limit );
protected:  /// manage components
	void Generate_Init_Component( Component & comp );  // not decompose the initial clauses
	Component & Current_Component() { return _comp_stack[_active_comps[_num_levels - 1]]; }
	Component & Parent_of_Current_Component() { return _comp_stack[_active_comps[_num_levels - 2]]; }
	Component & Previous_Component() { return _comp_stack[_active_comps[_num_levels - 1] - 1]; }
	Component & Active_Component( unsigned level ) const { return _comp_stack[_active_comps[level]]; }
	Component & Parent_of_Active_Component( unsigned level ) { return _comp_stack[_active_comps[level - 1]]; }
	unsigned Num_Components_On_Current_Level() const { return _num_comp_stack - _comp_offsets[_num_levels - 1]; }
	unsigned Num_Components_On_Level( unsigned level ) const { _comp_offsets[_num_levels] = _num_comp_stack;  return _comp_offsets[level + 1] - _comp_offsets[level]; }
	unsigned Active_Position_On_Level( unsigned level ) const { return _active_comps[level] - _comp_offsets[level]; }
	bool Is_Current_Level_Empty() const { return _num_comp_stack == _comp_offsets[_num_levels - 1]; }
	bool Is_Current_Level_Decision() const { return _num_comp_stack == _comp_offsets[_num_levels - 1] + 1; }
	bool Is_Current_Level_Decomposition() const { return _num_comp_stack > _comp_offsets[_num_levels - 1] + 1; }
	bool Is_Current_Level_Active() const { return _active_comps[_num_levels - 1] < _num_comp_stack; }
	bool Is_Level_Decision( unsigned level ) const { _comp_offsets[_num_levels] = _num_comp_stack;  return _comp_offsets[level + 1] == _comp_offsets[level] + 1; }
	bool Finished_Decision_Of_Current_Component() const
	{
		if ( Is_Current_Level_Decision() ) return _state_stack[_num_levels - 1] == 3;
		else return _state_stack[_num_levels - 1] % 3 == 2;
	}
	unsigned Level_Of_Component( unsigned pos ) const
	{
		unsigned level = _num_levels - 1;
		for ( ; ; level-- ) {
			if ( pos >= _comp_offsets[level] ) return level;
		}
		return UNSIGNED_UNDEF;
	}
	unsigned Dynamic_Decompose_Component( Component & source, Component smaller_comps[] );
	unsigned Dynamic_Decompose_Component_With_Sorting( Component & source, Component smaller_comps[] );
	void Add_Var_Neighbors_In_Binary_Clauses( Variable var, Component & target );
	void Add_Var_Neighbors_In_Beyond_2_Clauses( Variable var, Component & target );
	unsigned Dynamic_Decompose_Component_Without_Sorting( Component & source, Component smaller_comps[] );
	void Filter_Vars_Clauses_In_Component( Component & source, unsigned & num_vars, unsigned & num_cls );  // use var_rank and clause_stack to record
	void Add_Var_Neighbors_In_Ternary_Clauses( Variable var, Component & target );
	void Add_Var_Neighbors_In_Quaternary_Clauses( Variable var, Component & target );
	void Add_Var_Neighbors_In_Beyond_4_Clauses( Variable var, Component & target );
	bool Generate_Current_Component( Component & parent, Component & current );
	CNF_Formula * Output_Original_Clauses_In_Component( Component & comp );
	CNF_Formula * Output_Original_And_Learnt_Clauses_In_Component( Component & comp );
	CNF_Formula * Output_Renamed_Clauses_In_Component( Component & comp );
	WCNF_Formula * Output_Renamed_Clauses_In_Component( Component & comp, BigFloat * weights );
	void Output_Renamed_Clauses_In_Component( Component & comp, vector<Clause> & clauses );
	void Output_Renamed_Clauses_In_Component( Component & comp, vector<vector<int>> & eclauses );
public:
	void Input_Models( vector<Model *> & source );  // clone, the input location is model_stack[0], Inprocessor::max_var still isn't known
	void Input_Models_Component( Component & comp, vector<Model *> & source );  // clone, the input location is model_stack[0], Inprocessor::max_var still isn't known
	void Lend_Models( vector<Model *> & models, unsigned size );  // Inprocessor::max_var still isn't known
protected:  /// process models
	void Pick_Models( vector<Model *> & source, Literal lit, vector<Model *> & target );
	void Move_Models( vector<Model *> & source, vector<Model *> & target );
	void Inherit_Models( vector<Model *> & source, Literal lit, vector<Model *> & target );  // Copy and Pick
	void Copy_Models( vector<Model *> & source, vector<Model *> & target );
	void Recycle_Models( vector<Model *> & models );
	void Swap_Models( vector<Model *> & source, vector<Model *> & target ) { source.swap( target ); }
	void Raise_Models( vector<Model *> & source, unsigned target_level );
	void Display_Models( vector<Model *> & source, ostream & fout );
protected:
	BigInt Count_Verified_Models_sharpSAT( CNF_Formula & cnf );
	BigInt Count_Verified_Models_d4( CNF_Formula & cnf );
	BigFloat Count_Verified_Models_ganak( CNF_Formula & cnf, double weights[] );
	BigFloat Count_Verified_Models_ADDMC( CNF_Formula & cnf, double weights[] );
	BigFloat Count_Verified_Models_c2d( WCNF_Formula & cnf );
	void Gather_Learnts_Infor();
	void Verify_Model_Component( Model * model, Component & comp );
	void Verify_Models_Component( vector<Model *> models, Component & comp );
	void Verify_Membership_Lists();
	CNF_Formula * Output_Old_Clauses();
	void Display_Heuristic_Values( ostream & fout );
	void Display_Conflict( Reason confl, ostream & out );
	void Display_Comp_Stack( ostream & out );
	void Display_Comp_And_Decision_Stacks( ostream & out );
	void Display_Component( Component & comp, ostream & out );
	void Display_Component_Fixed_Len( Component & comp, ostream & out, unsigned len );
	void Display_Clauses_For_Counting_Component( ostream & out, Component & comp );
	void Display_Clauses_For_Counting_Component( ostream & out, Component comps[], unsigned num_comp );
	void Display_Clauses_For_Verifying_Imp( ostream & out, Clause & clause );
	void Display_Var_Membership_Lists_With_Sorting( ostream & out );
};


}


#endif  // _Inprocessor_h_
